
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000858  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  00000858  000008cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000045  00800064  0000085c  000008d0  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  000008d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000020d  00000000  00000000  00000910  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000a65  00000000  00000000  00000b1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000422  00000000  00000000  00001582  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000672  00000000  00000000  000019a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000080  00000000  00000000  00002018  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003d2  00000000  00000000  00002098  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000047c  00000000  00000000  0000246a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  000028e6  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
   2:	7d c2       	rjmp	.+1274   	; 0x4fe <__vector_1>
   4:	d1 c0       	rjmp	.+418    	; 0x1a8 <__vector_2>
   6:	5c c0       	rjmp	.+184    	; 0xc0 <__bad_interrupt>
   8:	5b c0       	rjmp	.+182    	; 0xc0 <__bad_interrupt>
   a:	5a c0       	rjmp	.+180    	; 0xc0 <__bad_interrupt>
   c:	59 c0       	rjmp	.+178    	; 0xc0 <__bad_interrupt>
   e:	58 c0       	rjmp	.+176    	; 0xc0 <__bad_interrupt>
  10:	57 c0       	rjmp	.+174    	; 0xc0 <__bad_interrupt>
  12:	56 c0       	rjmp	.+172    	; 0xc0 <__bad_interrupt>
  14:	55 c0       	rjmp	.+170    	; 0xc0 <__bad_interrupt>
  16:	54 c0       	rjmp	.+168    	; 0xc0 <__bad_interrupt>
  18:	53 c0       	rjmp	.+166    	; 0xc0 <__bad_interrupt>
  1a:	52 c0       	rjmp	.+164    	; 0xc0 <__bad_interrupt>
  1c:	51 c0       	rjmp	.+162    	; 0xc0 <__bad_interrupt>
  1e:	50 c0       	rjmp	.+160    	; 0xc0 <__bad_interrupt>
  20:	4f c0       	rjmp	.+158    	; 0xc0 <__bad_interrupt>
  22:	4e c0       	rjmp	.+156    	; 0xc0 <__bad_interrupt>
  24:	4d c0       	rjmp	.+154    	; 0xc0 <__bad_interrupt>

00000026 <usbDescriptorString0>:
  26:	04 03 09 04                                         ....

0000002a <usbDescriptorStringVendor>:
  2a:	1e 03 41 00 72 00 74 00 65 00 6d 00 20 00 53 00     ..A.r.t.e.m. .S.
  3a:	6f 00 66 00 74 00 77 00 61 00 72 00 65 00           o.f.t.w.a.r.e.

00000048 <usbDescriptorStringDevice>:
  48:	16 03 55 00 53 00 42 00 41 00 56 00 52 00 32 00     ..U.S.B.A.V.R.2.
  58:	33 00 31 00 33 00                                   3.1.3.

0000005e <usbDescriptorDevice>:
  5e:	12 01 01 01 ff 00 00 08 11 11 22 22 00 01 01 02     ..........""....
  6e:	00 01                                               ..

00000070 <usbDescriptorConfiguration>:
  70:	09 02 19 00 01 01 00 40 0a 09 04 00 00 01 00 00     .......@........
  80:	00 00 07 05 81 03 08 00 0a 00                       ..........

0000008a <__ctors_end>:
  8a:	11 24       	eor	r1, r1
  8c:	1f be       	out	0x3f, r1	; 63
  8e:	cf e5       	ldi	r28, 0x5F	; 95
  90:	d4 e0       	ldi	r29, 0x04	; 4
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
  96:	10 e0       	ldi	r17, 0x00	; 0
  98:	a0 e6       	ldi	r26, 0x60	; 96
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	e8 e5       	ldi	r30, 0x58	; 88
  9e:	f8 e0       	ldi	r31, 0x08	; 8
  a0:	02 c0       	rjmp	.+4      	; 0xa6 <.do_copy_data_start>

000000a2 <.do_copy_data_loop>:
  a2:	05 90       	lpm	r0, Z+
  a4:	0d 92       	st	X+, r0

000000a6 <.do_copy_data_start>:
  a6:	a4 36       	cpi	r26, 0x64	; 100
  a8:	b1 07       	cpc	r27, r17
  aa:	d9 f7       	brne	.-10     	; 0xa2 <.do_copy_data_loop>

000000ac <__do_clear_bss>:
  ac:	10 e0       	ldi	r17, 0x00	; 0
  ae:	a4 e6       	ldi	r26, 0x64	; 100
  b0:	b0 e0       	ldi	r27, 0x00	; 0
  b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
  b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
  b6:	a9 3a       	cpi	r26, 0xA9	; 169
  b8:	b1 07       	cpc	r27, r17
  ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
  bc:	8d d0       	rcall	.+282    	; 0x1d8 <main>
  be:	ca c3       	rjmp	.+1940   	; 0x854 <_exit>

000000c0 <__bad_interrupt>:
  c0:	9f cf       	rjmp	.-194    	; 0x0 <__vectors>

000000c2 <usbFunctionSetup>:
        //computeOutputStatus();
    }
}

uchar   usbFunctionSetup(uchar data[8])
{
  c2:	dc 01       	movw	r26, r24
	if (data[1]  == 0xA1)
  c4:	11 96       	adiw	r26, 0x01	; 1
  c6:	8c 91       	ld	r24, X
  c8:	11 97       	sbiw	r26, 0x01	; 1
  ca:	81 3a       	cpi	r24, 0xA1	; 161
  cc:	11 f4       	brne	.+4      	; 0xd2 <usbFunctionSetup+0x10>
		PORTC |= _BV(PC5);
  ce:	ad 9a       	sbi	0x15, 5	; 21
  d0:	01 c0       	rjmp	.+2      	; 0xd4 <usbFunctionSetup+0x12>
	else
		PORTC &= ~_BV(PC5);
  d2:	ad 98       	cbi	0x15, 5	; 21
    sei();
}

static uchar    eepromRead(uchar addr)
{
    while(EECR & (1 << EEWE));
  d4:	e1 99       	sbic	0x1c, 1	; 28
  d6:	fe cf       	rjmp	.-4      	; 0xd4 <usbFunctionSetup+0x12>
    EEARL = addr;
  d8:	85 e2       	ldi	r24, 0x25	; 37
  da:	8e bb       	out	0x1e, r24	; 30
    EECR |= 1 << EERE;
  dc:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
  de:	4d b3       	in	r20, 0x1d	; 29
    //flag = data[1];

uchar           status = eepromRead(EEPROM_LOCATION);
static uchar    replyBuf[2];

    usbMsgPtr = replyBuf;
  e0:	85 e6       	ldi	r24, 0x65	; 101
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	90 93 a3 00 	sts	0x00A3, r25
  e8:	80 93 a2 00 	sts	0x00A2, r24
    if(data[1] == 0){       /* ECHO */
  ec:	11 96       	adiw	r26, 0x01	; 1
  ee:	3c 91       	ld	r19, X
  f0:	11 97       	sbiw	r26, 0x01	; 1
  f2:	33 23       	and	r19, r19
  f4:	51 f4       	brne	.+20     	; 0x10a <usbFunctionSetup+0x48>
        replyBuf[0] = data[2];
  f6:	12 96       	adiw	r26, 0x02	; 2
  f8:	8c 91       	ld	r24, X
  fa:	12 97       	sbiw	r26, 0x02	; 2
  fc:	80 93 65 00 	sts	0x0065, r24
        replyBuf[1] = data[3];
 100:	13 96       	adiw	r26, 0x03	; 3
 102:	8c 91       	ld	r24, X
 104:	80 93 66 00 	sts	0x0066, r24
 108:	14 c0       	rjmp	.+40     	; 0x132 <usbFunctionSetup+0x70>
        return 2;
    }
    if(data[1] == 1){       /* GET_STATUS -> result = 2 bytes */
 10a:	31 30       	cpi	r19, 0x01	; 1
 10c:	a1 f4       	brne	.+40     	; 0x136 <usbFunctionSetup+0x74>
        replyBuf[0] = status;
 10e:	40 93 65 00 	sts	0x0065, r20
 112:	e7 e6       	ldi	r30, 0x67	; 103
 114:	f0 e0       	ldi	r31, 0x00	; 0
 116:	20 e0       	ldi	r18, 0x00	; 0
 118:	91 e0       	ldi	r25, 0x01	; 1
static uchar    computeTemporaryChanges(void)
{
uchar   i, status = 0, mask = 1;

    for(i=0;i<8;i++){
        if(actionTimers[i])
 11a:	80 81       	ld	r24, Z
 11c:	81 11       	cpse	r24, r1
            status |= mask;
 11e:	29 2b       	or	r18, r25
 120:	31 96       	adiw	r30, 0x01	; 1

static uchar    computeTemporaryChanges(void)
{
uchar   i, status = 0, mask = 1;

    for(i=0;i<8;i++){
 122:	80 e0       	ldi	r24, 0x00	; 0
 124:	ef 36       	cpi	r30, 0x6F	; 111
 126:	f8 07       	cpc	r31, r24
 128:	11 f0       	breq	.+4      	; 0x12e <usbFunctionSetup+0x6c>
        if(actionTimers[i])
            status |= mask;
        mask <<= 1;
 12a:	99 0f       	add	r25, r25
 12c:	f6 cf       	rjmp	.-20     	; 0x11a <usbFunctionSetup+0x58>
        replyBuf[1] = data[3];
        return 2;
    }
    if(data[1] == 1){       /* GET_STATUS -> result = 2 bytes */
        replyBuf[0] = status;
        replyBuf[1] = computeTemporaryChanges();
 12e:	20 93 66 00 	sts	0x0066, r18
 132:	82 e0       	ldi	r24, 0x02	; 2
 134:	08 95       	ret
        return 2;
    }
    if(data[1] == 2 || data[1] == 3){   /* SWITCH_ON or SWITCH_OFF, index = bit number */
 136:	83 2f       	mov	r24, r19
 138:	82 50       	subi	r24, 0x02	; 2
 13a:	82 30       	cpi	r24, 0x02	; 2
 13c:	98 f5       	brcc	.+102    	; 0x1a4 <usbFunctionSetup+0xe2>
        uchar bit = data[4] & 7;
        uchar mask = 1 << bit;
 13e:	14 96       	adiw	r26, 0x04	; 4
 140:	2c 91       	ld	r18, X
 142:	14 97       	sbiw	r26, 0x04	; 4
 144:	27 70       	andi	r18, 0x07	; 7
 146:	e2 2f       	mov	r30, r18
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	01 c0       	rjmp	.+2      	; 0x152 <usbFunctionSetup+0x90>
 150:	88 0f       	add	r24, r24
 152:	2a 95       	dec	r18
 154:	ea f7       	brpl	.-6      	; 0x150 <usbFunctionSetup+0x8e>
        uchar needChange, isOn = status & mask;
 156:	98 2f       	mov	r25, r24
 158:	94 23       	and	r25, r20
        if(data[1] == 2){   /* SWITCH_ON */
 15a:	32 30       	cpi	r19, 0x02	; 2
 15c:	39 f4       	brne	.+14     	; 0x16c <usbFunctionSetup+0xaa>
            status |= mask;
 15e:	38 2f       	mov	r19, r24
 160:	34 2b       	or	r19, r20
            needChange = !isOn;
 162:	20 e0       	ldi	r18, 0x00	; 0
 164:	99 23       	and	r25, r25
 166:	31 f4       	brne	.+12     	; 0x174 <usbFunctionSetup+0xb2>
 168:	21 e0       	ldi	r18, 0x01	; 1
 16a:	04 c0       	rjmp	.+8      	; 0x174 <usbFunctionSetup+0xb2>
        }else{              /* SWITCH_OFF */
            status &= ~mask;
 16c:	38 2f       	mov	r19, r24
 16e:	30 95       	com	r19
 170:	34 23       	and	r19, r20
 172:	29 2f       	mov	r18, r25
            needChange = isOn;
        }
        if(data[2] == 0){       /* duration == 0 -> permanent switch */
 174:	12 96       	adiw	r26, 0x02	; 2
 176:	8c 91       	ld	r24, X
 178:	88 23       	and	r24, r24
 17a:	69 f4       	brne	.+26     	; 0x196 <usbFunctionSetup+0xd4>
            actionTimers[bit] = 0;
 17c:	e9 59       	subi	r30, 0x99	; 153
 17e:	ff 4f       	sbci	r31, 0xFF	; 255
 180:	10 82       	st	Z, r1
#define    EEMWE   2
#define    EEWE    1

static void eepromWrite(unsigned char addr, unsigned char val)
{
    while(EECR & (1 << EEWE));
 182:	e1 99       	sbic	0x1c, 1	; 28
 184:	fe cf       	rjmp	.-4      	; 0x182 <usbFunctionSetup+0xc0>
    EEARL = addr;
 186:	85 e2       	ldi	r24, 0x25	; 37
 188:	8e bb       	out	0x1e, r24	; 30
    EEDR = val;
 18a:	3d bb       	out	0x1d, r19	; 29
    cli();
 18c:	f8 94       	cli
    EECR |= 1 << EEMWE;
 18e:	e2 9a       	sbi	0x1c, 2	; 28
    EECR |= 1 << EEWE;  /* must follow within a couple of cycles -- therefore cli() */
 190:	e1 9a       	sbi	0x1c, 1	; 28
    sei();
 192:	78 94       	sei
 194:	05 c0       	rjmp	.+10     	; 0x1a0 <usbFunctionSetup+0xde>
            needChange = isOn;
        }
        if(data[2] == 0){       /* duration == 0 -> permanent switch */
            actionTimers[bit] = 0;
            eepromWrite(EEPROM_LOCATION, status);
        }else if(needChange){   /* temporary switch: value = duration in 200ms units */
 196:	22 23       	and	r18, r18
 198:	29 f0       	breq	.+10     	; 0x1a4 <usbFunctionSetup+0xe2>
            actionTimers[bit] = data[2];
 19a:	e9 59       	subi	r30, 0x99	; 153
 19c:	ff 4f       	sbci	r31, 0xFF	; 255
 19e:	80 83       	st	Z, r24
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	08 95       	ret
 1a4:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
   // computeOutputStatus();

	return 0;
}
 1a6:	08 95       	ret

000001a8 <__vector_2>:
#if !defined TIFR && defined TIFR0
#define TIFR    TIFR0
#endif

SIGNAL(SIG_INTERRUPT1)
{
 1a8:	1f 92       	push	r1
 1aa:	0f 92       	push	r0
 1ac:	0f b6       	in	r0, 0x3f	; 63
 1ae:	0f 92       	push	r0
 1b0:	11 24       	eor	r1, r1
 1b2:	8f 93       	push	r24
    //GIMSK &= ~_BV(INT1);
    //TCCR1A = _BV(CS02) | _BV(CS00);		//  делитель 1024
    //TCNT1 = 50000;

	if (flag)
 1b4:	80 91 87 00 	lds	r24, 0x0087
 1b8:	88 23       	and	r24, r24
 1ba:	21 f0       	breq	.+8      	; 0x1c4 <__vector_2+0x1c>
	{
		flag = 0;
 1bc:	10 92 87 00 	sts	0x0087, r1
		PORTC &= ~_BV(PC4);
 1c0:	ac 98       	cbi	0x15, 4	; 21
 1c2:	04 c0       	rjmp	.+8      	; 0x1cc <__vector_2+0x24>
		//PORTC = 0xFF;
	}
	else
	{
		flag = 1;
 1c4:	81 e0       	ldi	r24, 0x01	; 1
 1c6:	80 93 87 00 	sts	0x0087, r24
		PORTC |= _BV(PC4);
 1ca:	ac 9a       	sbi	0x15, 4	; 21
		//PORTC = 0;
	}
}
 1cc:	8f 91       	pop	r24
 1ce:	0f 90       	pop	r0
 1d0:	0f be       	out	0x3f, r0	; 63
 1d2:	0f 90       	pop	r0
 1d4:	1f 90       	pop	r1
 1d6:	18 95       	reti

000001d8 <main>:

int main(void)
{
 1d8:	1f 93       	push	r17
	uchar   i, j;

	flag = 0;
 1da:	10 92 87 00 	sts	0x0087, r1
    wdt_enable(WDTO_1S);
 1de:	2e e0       	ldi	r18, 0x0E	; 14
 1e0:	88 e1       	ldi	r24, 0x18	; 24
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	0f b6       	in	r0, 0x3f	; 63
 1e6:	f8 94       	cli
 1e8:	a8 95       	wdr
 1ea:	81 bd       	out	0x21, r24	; 33
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	21 bd       	out	0x21, r18	; 33
    odDebugInit();
   // DDRD = ~(1 << 2);   /* all outputs except PD2 = INT0 */
    PORTD = 0;
 1f0:	12 ba       	out	0x12, r1	; 18
    PORTB = 0;          /* no pullups on USB pins */
 1f2:	18 ba       	out	0x18, r1	; 24
    PORTC = 0;
 1f4:	15 ba       	out	0x15, r1	; 21
   // PORTC |= _BV(PC5);

    DDRB = ~0;          /* output SE0 for USB reset */
 1f6:	8f ef       	ldi	r24, 0xFF	; 255
 1f8:	87 bb       	out	0x17, r24	; 23
    DDRC = 0xFF;
 1fa:	84 bb       	out	0x14, r24	; 20
    PORTC |= _BV(PC5);
 1fc:	ad 9a       	sbi	0x15, 5	; 21
    PORTC |= _BV(PC4);
 1fe:	ac 9a       	sbi	0x15, 4	; 21
    j = 0;
    while(--j){         /* USB Reset by device only required on Watchdog Reset */
        i = 0;
        while(--i);     /* delay >10ms for USB reset */
    }
    DDRB = ~USBMASK;    /* all outputs except USB data */
 200:	8c ef       	ldi	r24, 0xFC	; 252
 202:	87 bb       	out	0x17, r24	; 23
    TCCR0 = 5;          /* set prescaler to 1/1024 */
 204:	85 e0       	ldi	r24, 0x05	; 5
 206:	83 bf       	out	0x33, r24	; 51
    usbInit();
 208:	2b d0       	rcall	.+86     	; 0x260 <usbInit>
    sei();
 20a:	78 94       	sei

	//PORTB |= _BV(PB2);
	GIMSK |= _BV(INT1);
 20c:	8b b7       	in	r24, 0x3b	; 59
 20e:	80 68       	ori	r24, 0x80	; 128
 210:	8b bf       	out	0x3b, r24	; 59
{
static uchar    prescaler;
uchar           i;

    if(!prescaler--){
        prescaler = 8;  /* rate = 12M / 1024 * 256 * 9 */
 212:	18 e0       	ldi	r17, 0x08	; 8

	//PORTB |= _BV(PB2);
	GIMSK |= _BV(INT1);

    for(;;){    /* main event loop */
        wdt_reset();
 214:	a8 95       	wdr
        usbPoll();
 216:	32 d0       	rcall	.+100    	; 0x27c <usbPoll>
        if(TIFR & (1 << TOV0)){
 218:	08 b6       	in	r0, 0x38	; 56
 21a:	00 fe       	sbrs	r0, 0
 21c:	18 c0       	rjmp	.+48     	; 0x24e <main+0x76>
            TIFR |= 1 << TOV0;  /* clear pending flag */
 21e:	88 b7       	in	r24, 0x38	; 56
 220:	81 60       	ori	r24, 0x01	; 1
 222:	88 bf       	out	0x38, r24	; 56
static void timerInterrupt(void)
{
static uchar    prescaler;
uchar           i;

    if(!prescaler--){
 224:	80 91 64 00 	lds	r24, 0x0064
 228:	81 50       	subi	r24, 0x01	; 1
 22a:	80 93 64 00 	sts	0x0064, r24
 22e:	8f 5f       	subi	r24, 0xFF	; 255
 230:	71 f4       	brne	.+28     	; 0x24e <main+0x76>
        prescaler = 8;  /* rate = 12M / 1024 * 256 * 9 */
 232:	10 93 64 00 	sts	0x0064, r17
 236:	e7 e6       	ldi	r30, 0x67	; 103
 238:	f0 e0       	ldi	r31, 0x00	; 0
        for(i=0;i<8;i++){
            if(actionTimers[i])
 23a:	80 81       	ld	r24, Z
 23c:	88 23       	and	r24, r24
 23e:	11 f0       	breq	.+4      	; 0x244 <main+0x6c>
                actionTimers[i]--;
 240:	81 50       	subi	r24, 0x01	; 1
 242:	80 83       	st	Z, r24
 244:	31 96       	adiw	r30, 0x01	; 1
static uchar    prescaler;
uchar           i;

    if(!prescaler--){
        prescaler = 8;  /* rate = 12M / 1024 * 256 * 9 */
        for(i=0;i<8;i++){
 246:	80 e0       	ldi	r24, 0x00	; 0
 248:	ef 36       	cpi	r30, 0x6F	; 111
 24a:	f8 07       	cpc	r31, r24
 24c:	b1 f7       	brne	.-20     	; 0x23a <main+0x62>
        if(TIFR & (1 << TOV0)){
            TIFR |= 1 << TOV0;  /* clear pending flag */
            timerInterrupt();
        }

        	if (usbInterruptIsReady())
 24e:	80 91 62 00 	lds	r24, 0x0062
 252:	84 ff       	sbrs	r24, 4
 254:	df cf       	rjmp	.-66     	; 0x214 <main+0x3c>
                usbSetInterrupt(&flag, 1);
 256:	61 e0       	ldi	r22, 0x01	; 1
 258:	87 e8       	ldi	r24, 0x87	; 135
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	27 d1       	rcall	.+590    	; 0x4ac <usbSetInterrupt>
 25e:	da cf       	rjmp	.-76     	; 0x214 <main+0x3c>

00000260 <usbInit>:
}

/* ------------------------------------------------------------------------- */

void    usbInit(void)
{
 260:	8f e6       	ldi	r24, 0x6F	; 111
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	80 93 9f 00 	sts	0x009F, r24
    usbInputBuf = (uchar)usbRxBuf[0];
    usbAppBuf = (uchar)usbRxBuf[1];
 268:	0b 96       	adiw	r24, 0x0b	; 11
 26a:	80 93 93 00 	sts	0x0093, r24
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
 26e:	85 b7       	in	r24, 0x35	; 53
 270:	83 60       	ori	r24, 0x03	; 3
 272:	85 bf       	out	0x35, r24	; 53
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 274:	8b b7       	in	r24, 0x3b	; 59
 276:	80 64       	ori	r24, 0x40	; 64
 278:	8b bf       	out	0x3b, r24	; 59
}
 27a:	08 95       	ret

0000027c <usbPoll>:
}

/* ------------------------------------------------------------------------- */

void    usbPoll(void)
{
 27c:	0f 93       	push	r16
 27e:	1f 93       	push	r17
 280:	cf 93       	push	r28
 282:	df 93       	push	r29
uchar   len;

    if((len = usbRxLen) > 0){
 284:	80 91 a5 00 	lds	r24, 0x00A5
 288:	88 23       	and	r24, r24
 28a:	09 f4       	brne	.+2      	; 0x28e <usbPoll+0x12>
 28c:	a6 c0       	rjmp	.+332    	; 0x3da <usbPoll+0x15e>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16((uchar *)(unsigned)(usbAppBuf + 1), usbRxLen - 3);
 */
        len -= 3;       /* remove PID and CRC */
 28e:	98 2f       	mov	r25, r24
 290:	93 50       	subi	r25, 0x03	; 3
        if(len < 128){  /* no overflow */
 292:	97 fd       	sbrc	r25, 7
 294:	a0 c0       	rjmp	.+320    	; 0x3d6 <usbPoll+0x15a>
            converter_t appBuf;
            appBuf.ptr = (uchar *)usbRxBuf;
 296:	2f e6       	ldi	r18, 0x6F	; 111
 298:	30 e0       	ldi	r19, 0x00	; 0
            appBuf.bytes[0] = usbAppBuf;
            appBuf.bytes[0]++;
 29a:	40 91 93 00 	lds	r20, 0x0093
 29e:	4f 5f       	subi	r20, 0xFF	; 255
        usbFunctionWriteOut(data, len);
        return; /* no reply expected, hence no usbMsgPtr, usbMsgFlags, usbMsgLen set */
    }
    if(usbRxToken == (uchar)(USBPID_SETUP & 0x7f)){ /* MSb contains endpoint (== 0) */
#else
    if(usbRxToken == (uchar)USBPID_SETUP)
 2a0:	80 91 a1 00 	lds	r24, 0x00A1
 2a4:	8d 32       	cpi	r24, 0x2D	; 45
 2a6:	09 f0       	breq	.+2      	; 0x2aa <usbPoll+0x2e>
 2a8:	8e c0       	rjmp	.+284    	; 0x3c6 <usbPoll+0x14a>
	{
#endif
        if(len == 8)
 2aa:	98 30       	cpi	r25, 0x08	; 8
 2ac:	09 f0       	breq	.+2      	; 0x2b0 <usbPoll+0x34>
 2ae:	8b c0       	rjmp	.+278    	; 0x3c6 <usbPoll+0x14a>
 * above was written, or other parts of the code have changed. We now get
 * better results with an inlined function. Test condition: PowerSwitch code.
 */
static void usbProcessRx(uchar *data, uchar len)
{
	usbRequest_t    *rq = (void *)data;
 2b0:	c4 2f       	mov	r28, r20
 2b2:	d3 2f       	mov	r29, r19
    if(usbRxToken == (uchar)USBPID_SETUP)
	{
#endif
        if(len == 8)
		{   /* Setup size must be always 8 bytes. Ignore otherwise. */
            uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 2b4:	98 81       	ld	r25, Y
            if(type == USBRQ_TYPE_STANDARD)
 2b6:	89 2f       	mov	r24, r25
 2b8:	80 76       	andi	r24, 0x60	; 96
 2ba:	09 f0       	breq	.+2      	; 0x2be <usbPoll+0x42>
 2bc:	75 c0       	rjmp	.+234    	; 0x3a8 <usbPoll+0x12c>
			{
                #define SET_REPLY_LEN(len)  replyLen = (len); usbMsgPtr = replyData
                /* This macro ensures that replyLen and usbMsgPtr are always set in the same way.
                 * That allows optimization of common code in if() branches */
                uchar *replyData = usbTxBuf + 9; /* there is 3 bytes free space at the end of the buffer */
                replyData[0] = 0;   /* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 2be:	10 92 91 00 	sts	0x0091, r1
                if(rq->bRequest == USBRQ_GET_STATUS)
 2c2:	89 81       	ldd	r24, Y+1	; 0x01
 2c4:	88 23       	and	r24, r24
 2c6:	81 f4       	brne	.+32     	; 0x2e8 <usbPoll+0x6c>
				{           /* 0 */
                    uchar __attribute__((__unused__)) recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
#if USB_CFG_IS_SELF_POWERED
                    if(recipient == USBRQ_RCPT_DEVICE)
 2c8:	9f 71       	andi	r25, 0x1F	; 31
 2ca:	19 f4       	brne	.+6      	; 0x2d2 <usbPoll+0x56>
                        replyData[0] =  USB_CFG_IS_SELF_POWERED;
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	80 93 91 00 	sts	0x0091, r24
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT && USB_CFG_IMPLEMENT_HALT
                    if(recipient == USBRQ_RCPT_ENDPOINT && rq->wIndex.bytes[0] == 0x81)   /* request status for endpoint 1 */
                        replyData[0] = usbTxLen1 == USBPID_STALL;
#endif
                    replyData[1] = 0;
 2d2:	10 92 92 00 	sts	0x0092, r1
                    SET_REPLY_LEN(2);
 2d6:	81 e9       	ldi	r24, 0x91	; 145
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	90 93 a3 00 	sts	0x00A3, r25
 2de:	80 93 a2 00 	sts	0x00A2, r24
 2e2:	20 e8       	ldi	r18, 0x80	; 128
 2e4:	92 e0       	ldi	r25, 0x02	; 2
 2e6:	68 c0       	rjmp	.+208    	; 0x3b8 <usbPoll+0x13c>
                }else if(rq->bRequest == USBRQ_SET_ADDRESS)
 2e8:	85 30       	cpi	r24, 0x05	; 5
 2ea:	21 f4       	brne	.+8      	; 0x2f4 <usbPoll+0x78>
				{    /* 5 */
                    usbNewDeviceAddr = rq->wValue.bytes[0];
 2ec:	8a 81       	ldd	r24, Y+2	; 0x02
 2ee:	80 93 a6 00 	sts	0x00A6, r24
 2f2:	58 c0       	rjmp	.+176    	; 0x3a4 <usbPoll+0x128>
                }else if(rq->bRequest == USBRQ_GET_DESCRIPTOR)
 2f4:	86 30       	cpi	r24, 0x06	; 6
 2f6:	e1 f5       	brne	.+120    	; 0x370 <usbPoll+0xf4>
				{ /* 6 */
                    flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
                    if(rq->wValue.bytes[1] == USBDESCR_DEVICE)
 2f8:	8b 81       	ldd	r24, Y+3	; 0x03
 2fa:	81 30       	cpi	r24, 0x01	; 1
 2fc:	49 f4       	brne	.+18     	; 0x310 <usbPoll+0x94>
					{ /* 1 */
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 2fe:	8e e5       	ldi	r24, 0x5E	; 94
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	90 93 a3 00 	sts	0x00A3, r25
 306:	80 93 a2 00 	sts	0x00A2, r24
 30a:	20 ec       	ldi	r18, 0xC0	; 192
 30c:	92 e1       	ldi	r25, 0x12	; 18
 30e:	54 c0       	rjmp	.+168    	; 0x3b8 <usbPoll+0x13c>
                    }else if(rq->wValue.bytes[1] == USBDESCR_CONFIG)
 310:	82 30       	cpi	r24, 0x02	; 2
 312:	49 f4       	brne	.+18     	; 0x326 <usbPoll+0xaa>
					{   /* 2 */
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 314:	80 e7       	ldi	r24, 0x70	; 112
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	90 93 a3 00 	sts	0x00A3, r25
 31c:	80 93 a2 00 	sts	0x00A2, r24
 320:	20 ec       	ldi	r18, 0xC0	; 192
 322:	99 e1       	ldi	r25, 0x19	; 25
 324:	49 c0       	rjmp	.+146    	; 0x3b8 <usbPoll+0x13c>
                    }else if(rq->wValue.bytes[1] == USBDESCR_STRING)
 326:	83 30       	cpi	r24, 0x03	; 3
 328:	09 f0       	breq	.+2      	; 0x32c <usbPoll+0xb0>
 32a:	44 c0       	rjmp	.+136    	; 0x3b4 <usbPoll+0x138>
#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
                        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
                            flags &= ~USB_FLG_MSGPTR_IS_ROM;
                        replyLen = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
                        if(rq->wValue.bytes[0] == 0){   /* descriptor index */
 32c:	8a 81       	ldd	r24, Y+2	; 0x02
 32e:	88 23       	and	r24, r24
 330:	49 f4       	brne	.+18     	; 0x344 <usbPoll+0xc8>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 332:	86 e2       	ldi	r24, 0x26	; 38
 334:	90 e0       	ldi	r25, 0x00	; 0
 336:	90 93 a3 00 	sts	0x00A3, r25
 33a:	80 93 a2 00 	sts	0x00A2, r24
 33e:	20 ec       	ldi	r18, 0xC0	; 192
 340:	94 e0       	ldi	r25, 0x04	; 4
 342:	3a c0       	rjmp	.+116    	; 0x3b8 <usbPoll+0x13c>
                        }else if(rq->wValue.bytes[0] == 1)
 344:	81 30       	cpi	r24, 0x01	; 1
 346:	49 f4       	brne	.+18     	; 0x35a <usbPoll+0xde>
						{
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 348:	8a e2       	ldi	r24, 0x2A	; 42
 34a:	90 e0       	ldi	r25, 0x00	; 0
 34c:	90 93 a3 00 	sts	0x00A3, r25
 350:	80 93 a2 00 	sts	0x00A2, r24
 354:	20 ec       	ldi	r18, 0xC0	; 192
 356:	9e e1       	ldi	r25, 0x1E	; 30
 358:	2f c0       	rjmp	.+94     	; 0x3b8 <usbPoll+0x13c>
                        }else if(rq->wValue.bytes[0] == 2)
 35a:	82 30       	cpi	r24, 0x02	; 2
 35c:	59 f5       	brne	.+86     	; 0x3b4 <usbPoll+0x138>
						{
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_DEVICE, usbDescriptorStringDevice)
 35e:	88 e4       	ldi	r24, 0x48	; 72
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	90 93 a3 00 	sts	0x00A3, r25
 366:	80 93 a2 00 	sts	0x00A2, r24
 36a:	20 ec       	ldi	r18, 0xC0	; 192
 36c:	96 e1       	ldi	r25, 0x16	; 22
 36e:	24 c0       	rjmp	.+72     	; 0x3b8 <usbPoll+0x13c>
					{   /* 0x22 */
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
                    }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                        replyLen = usbFunctionDescriptor(rq);
                    }
                }else if(rq->bRequest == USBRQ_GET_CONFIGURATION)
 370:	88 30       	cpi	r24, 0x08	; 8
 372:	19 f4       	brne	.+6      	; 0x37a <usbPoll+0xfe>
				{  /* 8 */
                    replyData = &usbConfiguration;  /* send current configuration value */
                    SET_REPLY_LEN(1);
 374:	88 ea       	ldi	r24, 0xA8	; 168
 376:	90 e0       	ldi	r25, 0x00	; 0
 378:	0a c0       	rjmp	.+20     	; 0x38e <usbPoll+0x112>
                }else if(rq->bRequest == USBRQ_SET_CONFIGURATION)
 37a:	89 30       	cpi	r24, 0x09	; 9
 37c:	21 f4       	brne	.+8      	; 0x386 <usbPoll+0x10a>
				{  /* 9 */
                    usbConfiguration = rq->wValue.bytes[0];
 37e:	8a 81       	ldd	r24, Y+2	; 0x02
 380:	80 93 a8 00 	sts	0x00A8, r24
 384:	0f c0       	rjmp	.+30     	; 0x3a4 <usbPoll+0x128>
#if USB_CFG_IMPLEMENT_HALT
                    usbTxLen1 = USBPID_NAK;
#endif
                }else if(rq->bRequest == USBRQ_GET_INTERFACE)
 386:	8a 30       	cpi	r24, 0x0A	; 10
 388:	49 f4       	brne	.+18     	; 0x39c <usbPoll+0x120>
				{      /* 10 */
                    SET_REPLY_LEN(1);
 38a:	81 e9       	ldi	r24, 0x91	; 145
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	90 93 a3 00 	sts	0x00A3, r25
 392:	80 93 a2 00 	sts	0x00A2, r24
 396:	20 e8       	ldi	r18, 0x80	; 128
 398:	91 e0       	ldi	r25, 0x01	; 1
 39a:	0e c0       	rjmp	.+28     	; 0x3b8 <usbPoll+0x13c>
#if USB_CFG_HAVE_INTRIN_ENDPOINT
                }else if(rq->bRequest == USBRQ_SET_INTERFACE)
 39c:	8b 30       	cpi	r24, 0x0B	; 11
 39e:	11 f4       	brne	.+4      	; 0x3a4 <usbPoll+0x128>
				{      /* 11 */
                    usbTxPacketCnt1 = 0;        /* reset data toggling for interrupt endpoint */
 3a0:	10 92 a4 00 	sts	0x00A4, r1
 3a4:	20 e8       	ldi	r18, 0x80	; 128
 3a6:	07 c0       	rjmp	.+14     	; 0x3b6 <usbPoll+0x13a>
                    /* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */
                    /* 12: SYNCH_FRAME */
                }
                #undef SET_REPLY_LEN
            }else{  /* not a standard request -- must be vendor or class request */
                replyLen = usbFunctionSetup(data);
 3a8:	84 2f       	mov	r24, r20
 3aa:	93 2f       	mov	r25, r19
 3ac:	8a de       	rcall	.-748    	; 0xc2 <usbFunctionSetup>
 3ae:	98 2f       	mov	r25, r24
 3b0:	20 e8       	ldi	r18, 0x80	; 128
 3b2:	02 c0       	rjmp	.+4      	; 0x3b8 <usbPoll+0x13c>
 3b4:	20 ec       	ldi	r18, 0xC0	; 192
 3b6:	90 e0       	ldi	r25, 0x00	; 0
                    replyLen = rq->wLength.bytes[0];    /* IN transfers only */
                }
                flags &= ~USB_FLG_USE_DEFAULT_RW;  /* we have no valid msg, use user supplied read/write functions */
            }else   /* The 'else' prevents that we limit a replyLen of 0xff to the maximum transfer len. */
#endif
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])  /* limit length to max */
 3b8:	8f 81       	ldd	r24, Y+7	; 0x07
 3ba:	88 23       	and	r24, r24
 3bc:	39 f4       	brne	.+14     	; 0x3cc <usbPoll+0x150>
 3be:	8e 81       	ldd	r24, Y+6	; 0x06
 3c0:	89 17       	cp	r24, r25
 3c2:	28 f0       	brcs	.+10     	; 0x3ce <usbPoll+0x152>
 3c4:	03 c0       	rjmp	.+6      	; 0x3cc <usbPoll+0x150>
 3c6:	20 e8       	ldi	r18, 0x80	; 128
 3c8:	80 e0       	ldi	r24, 0x00	; 0
 3ca:	01 c0       	rjmp	.+2      	; 0x3ce <usbPoll+0x152>
 3cc:	89 2f       	mov	r24, r25
            }
            flags = 0;    /* start with a DATA1 package, stay with user supplied write() function */
        }
#endif
    }
    usbMsgFlags = flags;
 3ce:	20 93 85 00 	sts	0x0085, r18
    usbMsgLen = replyLen;
 3d2:	80 93 60 00 	sts	0x0060, r24
        }
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;   /* mark rx buffer as available */
 3d6:	10 92 a5 00 	sts	0x00A5, r1
#endif
    }
    if(usbMsgLen != 0xff){  /* transmit data pending? */
 3da:	90 91 60 00 	lds	r25, 0x0060
 3de:	9f 3f       	cpi	r25, 0xFF	; 255
 3e0:	09 f4       	brne	.+2      	; 0x3e4 <usbPoll+0x168>
 3e2:	48 c0       	rjmp	.+144    	; 0x474 <__stack+0x15>
        if(usbTxLen & 0x10) /* transmit system idle */
 3e4:	80 91 61 00 	lds	r24, 0x0061
 3e8:	84 ff       	sbrs	r24, 4
 3ea:	44 c0       	rjmp	.+136    	; 0x474 <__stack+0x15>
 3ec:	19 2f       	mov	r17, r25
 3ee:	99 30       	cpi	r25, 0x09	; 9
 3f0:	08 f0       	brcs	.+2      	; 0x3f4 <usbPoll+0x178>
 3f2:	18 e0       	ldi	r17, 0x08	; 8
uchar       wantLen, len, txLen, token;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
 3f4:	91 1b       	sub	r25, r17
 3f6:	90 93 60 00 	sts	0x0060, r25
    token = USBPID_DATA1;
    if(usbMsgFlags & USB_FLG_TX_PACKET)
 3fa:	80 91 85 00 	lds	r24, 0x0085
 3fe:	80 fd       	sbrc	r24, 0
 400:	02 c0       	rjmp	.+4      	; 0x406 <usbPoll+0x18a>
 402:	0b e4       	ldi	r16, 0x4B	; 75
 404:	01 c0       	rjmp	.+2      	; 0x408 <usbPoll+0x18c>
 406:	03 ec       	ldi	r16, 0xC3	; 195
        token = USBPID_DATA0;
    usbMsgFlags++;
 408:	8f 5f       	subi	r24, 0xFF	; 255
 40a:	80 93 85 00 	sts	0x0085, r24
static uchar    usbRead(uchar *data, uchar len)
{
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
 40e:	20 91 a2 00 	lds	r18, 0x00A2
 412:	30 91 a3 00 	lds	r19, 0x00A3
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 416:	86 fd       	sbrc	r24, 6
 418:	05 c0       	rjmp	.+10     	; 0x424 <usbPoll+0x1a8>
 41a:	d9 01       	movw	r26, r18
 41c:	91 2f       	mov	r25, r17
 41e:	e9 e8       	ldi	r30, 0x89	; 137
 420:	f0 e0       	ldi	r31, 0x00	; 0
 422:	11 c0       	rjmp	.+34     	; 0x446 <usbPoll+0x1ca>
 424:	a9 e8       	ldi	r26, 0x89	; 137
 426:	b0 e0       	ldi	r27, 0x00	; 0
 428:	80 e0       	ldi	r24, 0x00	; 0
 42a:	90 e0       	ldi	r25, 0x00	; 0
 42c:	06 c0       	rjmp	.+12     	; 0x43a <usbPoll+0x1be>
            while(i--){
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
 42e:	f9 01       	movw	r30, r18
 430:	e8 0f       	add	r30, r24
 432:	f9 1f       	adc	r31, r25
 434:	e4 91       	lpm	r30, Z+
                *data++ = c;
 436:	ed 93       	st	X+, r30
 438:	01 96       	adiw	r24, 0x01	; 1
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
            while(i--){
 43a:	18 17       	cp	r17, r24
 43c:	c1 f7       	brne	.-16     	; 0x42e <usbPoll+0x1b2>
 43e:	05 c0       	rjmp	.+10     	; 0x44a <usbPoll+0x1ce>
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
                *data++ = *r++;
 440:	8d 91       	ld	r24, X+
 442:	81 93       	st	Z+, r24
 444:	91 50       	subi	r25, 0x01	; 1
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
 446:	99 23       	and	r25, r25
 448:	d9 f7       	brne	.-10     	; 0x440 <usbPoll+0x1c4>
 44a:	f9 01       	movw	r30, r18
 44c:	e1 0f       	add	r30, r17
 44e:	f1 1d       	adc	r31, r1
                *data++ = *r++;
        }
        usbMsgPtr = r;
 450:	f0 93 a3 00 	sts	0x00A3, r31
 454:	e0 93 a2 00 	sts	0x00A2, r30
    if(usbMsgFlags & USB_FLG_TX_PACKET)
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
 458:	61 2f       	mov	r22, r17
 45a:	89 e8       	ldi	r24, 0x89	; 137
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	f6 d1       	rcall	.+1004   	; 0x84c <usbCrc16Append>
        txLen = len + 4;    /* length including sync byte */
        if(len < 8)         /* a partial package identifies end of message */
 460:	18 30       	cpi	r17, 0x08	; 8
 462:	19 f0       	breq	.+6      	; 0x46a <__stack+0xb>
            usbMsgLen = 0xff;
 464:	8f ef       	ldi	r24, 0xFF	; 255
 466:	80 93 60 00 	sts	0x0060, r24
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
 46a:	00 93 88 00 	sts	0x0088, r16
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
        txLen = len + 4;    /* length including sync byte */
 46e:	1c 5f       	subi	r17, 0xFC	; 252
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
    usbTxLen = txLen;
 470:	10 93 61 00 	sts	0x0061, r17
/* We want to do
 *     return (USBIN & USBMASK);
 * here, but the compiler does int-expansion acrobatics.
 * We can avoid this by assigning to a char-sized variable.
 */
    rval = USBIN & USBMASK;
 474:	86 b3       	in	r24, 0x16	; 22
    }
    if(usbMsgLen != 0xff){  /* transmit data pending? */
        if(usbTxLen & 0x10) /* transmit system idle */
            usbBuildTxBlock();
    }
    if(isNotSE0()){ /* SE0 state */
 476:	83 70       	andi	r24, 0x03	; 3
 478:	19 f0       	breq	.+6      	; 0x480 <__stack+0x21>
        usbIsReset = 0;
 47a:	10 92 86 00 	sts	0x0086, r1
 47e:	11 c0       	rjmp	.+34     	; 0x4a2 <__stack+0x43>
    }else{
        /* check whether SE0 lasts for more than 2.5us (3.75 bit times) */
        if(!usbIsReset){
 480:	80 91 86 00 	lds	r24, 0x0086
 484:	88 23       	and	r24, r24
 486:	69 f4       	brne	.+26     	; 0x4a2 <__stack+0x43>
 488:	94 e6       	ldi	r25, 0x64	; 100
/* We want to do
 *     return (USBIN & USBMASK);
 * here, but the compiler does int-expansion acrobatics.
 * We can avoid this by assigning to a char-sized variable.
 */
    rval = USBIN & USBMASK;
 48a:	86 b3       	in	r24, 0x16	; 22
    }else{
        /* check whether SE0 lasts for more than 2.5us (3.75 bit times) */
        if(!usbIsReset){
            uchar i;
            for(i=100;i;i--){
                if(isNotSE0())
 48c:	83 70       	andi	r24, 0x03	; 3
 48e:	49 f4       	brne	.+18     	; 0x4a2 <__stack+0x43>
        usbIsReset = 0;
    }else{
        /* check whether SE0 lasts for more than 2.5us (3.75 bit times) */
        if(!usbIsReset){
            uchar i;
            for(i=100;i;i--){
 490:	91 50       	subi	r25, 0x01	; 1
 492:	d9 f7       	brne	.-10     	; 0x48a <__stack+0x2b>
                if(isNotSE0())
                    goto notUsbReset;
            }
            usbIsReset = 1;
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	80 93 86 00 	sts	0x0086, r24
            usbNewDeviceAddr = 0;
 49a:	10 92 a6 00 	sts	0x00A6, r1
            usbDeviceAddr = 0;
 49e:	10 92 a0 00 	sts	0x00A0, r1
#endif
            DBG1(0xff, 0, 0);
notUsbReset:;
        }
    }
}
 4a2:	df 91       	pop	r29
 4a4:	cf 91       	pop	r28
 4a6:	1f 91       	pop	r17
 4a8:	0f 91       	pop	r16
 4aa:	08 95       	ret

000004ac <usbSetInterrupt>:

#if USB_CFG_HAVE_INTRIN_ENDPOINT
uchar   usbTxPacketCnt1;

void    usbSetInterrupt(uchar *data, uchar len)
{
 4ac:	1f 93       	push	r17
 4ae:	dc 01       	movw	r26, r24
 4b0:	16 2f       	mov	r17, r22
#if 0   /* No runtime checks! Caller is responsible for valid data! */
    if(len > 8) /* interrupt transfers are limited to 8 bytes */
        len = 8;
#endif
    i = USBPID_DATA1;
    if(usbTxPacketCnt1 & 1)
 4b2:	90 91 a4 00 	lds	r25, 0x00A4
 4b6:	90 fd       	sbrc	r25, 0
 4b8:	02 c0       	rjmp	.+4      	; 0x4be <usbSetInterrupt+0x12>
 4ba:	2b e4       	ldi	r18, 0x4B	; 75
 4bc:	01 c0       	rjmp	.+2      	; 0x4c0 <usbSetInterrupt+0x14>
 4be:	23 ec       	ldi	r18, 0xC3	; 195
        i = USBPID_DATA0;
    if(usbTxLen1 & 0x10){       /* packet buffer was empty */
 4c0:	80 91 62 00 	lds	r24, 0x0062
 4c4:	84 ff       	sbrs	r24, 4
 4c6:	04 c0       	rjmp	.+8      	; 0x4d0 <usbSetInterrupt+0x24>
        usbTxPacketCnt1++;
 4c8:	9f 5f       	subi	r25, 0xFF	; 255
 4ca:	90 93 a4 00 	sts	0x00A4, r25
 4ce:	03 c0       	rjmp	.+6      	; 0x4d6 <usbSetInterrupt+0x2a>
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending incomplete interrupt data */
 4d0:	8a e5       	ldi	r24, 0x5A	; 90
 4d2:	80 93 62 00 	sts	0x0062, r24
    }
    p = usbTxBuf1;
    *p++ = i;
 4d6:	20 93 94 00 	sts	0x0094, r18
 4da:	91 2f       	mov	r25, r17
 4dc:	e5 e9       	ldi	r30, 0x95	; 149
 4de:	f0 e0       	ldi	r31, 0x00	; 0
 4e0:	03 c0       	rjmp	.+6      	; 0x4e8 <usbSetInterrupt+0x3c>
    for(i=len;i--;)
        *p++ = *data++;
 4e2:	8d 91       	ld	r24, X+
 4e4:	81 93       	st	Z+, r24
 4e6:	91 50       	subi	r25, 0x01	; 1
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending incomplete interrupt data */
    }
    p = usbTxBuf1;
    *p++ = i;
    for(i=len;i--;)
 4e8:	99 23       	and	r25, r25
 4ea:	d9 f7       	brne	.-10     	; 0x4e2 <usbSetInterrupt+0x36>
        *p++ = *data++;
    usbCrc16Append(&usbTxBuf1[1], len);
 4ec:	61 2f       	mov	r22, r17
 4ee:	85 e9       	ldi	r24, 0x95	; 149
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	ac d1       	rcall	.+856    	; 0x84c <usbCrc16Append>
    usbTxLen1 = len + 4;    /* len must be given including sync byte */
 4f4:	1c 5f       	subi	r17, 0xFC	; 252
 4f6:	10 93 62 00 	sts	0x0062, r17
    DBG2(0x21, usbTxBuf1, len + 3);
}
 4fa:	1f 91       	pop	r17
 4fc:	08 95       	ret

000004fe <__vector_1>:
 4fe:	0f 93       	push	r16
 500:	0f b7       	in	r16, 0x3f	; 63
 502:	0f 93       	push	r16
 504:	05 e0       	ldi	r16, 0x05	; 5

00000506 <waitForJ>:
 506:	b0 9b       	sbis	0x16, 0	; 22
 508:	fe cf       	rjmp	.-4      	; 0x506 <waitForJ>

0000050a <waitForK>:
 50a:	0a 95       	dec	r16
 50c:	b0 99       	sbic	0x16, 0	; 22
 50e:	e9 f7       	brne	.-6      	; 0x50a <waitForK>
 510:	1f 93       	push	r17
 512:	3f 93       	push	r19
 514:	2f 93       	push	r18

00000516 <shortcutEntry>:
 516:	31 e0       	ldi	r19, 0x01	; 1
 518:	12 e0       	ldi	r17, 0x02	; 2

0000051a <waitNoChange>:
 51a:	06 b3       	in	r16, 0x16	; 22
 51c:	10 27       	eor	r17, r16
 51e:	10 fd       	sbrc	r17, 0
 520:	32 e0       	ldi	r19, 0x02	; 2
 522:	10 2f       	mov	r17, r16
 524:	3a 95       	dec	r19
 526:	c9 f7       	brne	.-14     	; 0x51a <waitNoChange>
 528:	00 fd       	sbrc	r16, 0
 52a:	e1 c0       	rjmp	.+450    	; 0x6ee <sofError>
 52c:	06 b3       	in	r16, 0x16	; 22
 52e:	10 27       	eor	r17, r16
 530:	20 e0       	ldi	r18, 0x00	; 0
 532:	10 fb       	bst	r17, 0
 534:	20 f9       	bld	r18, 0
 536:	df 93       	push	r29
 538:	16 b3       	in	r17, 0x16	; 22
 53a:	01 27       	eor	r16, r17
 53c:	00 fb       	bst	r16, 0
 53e:	21 f9       	bld	r18, 1
 540:	cf 93       	push	r28
 542:	c0 91 9f 00 	lds	r28, 0x009F
 546:	06 b3       	in	r16, 0x16	; 22
 548:	10 27       	eor	r17, r16
 54a:	10 fb       	bst	r17, 0
 54c:	22 f9       	bld	r18, 2
 54e:	3b e0       	ldi	r19, 0x0B	; 11
 550:	d0 e0       	ldi	r29, 0x00	; 0
 552:	4f 93       	push	r20
 554:	16 b3       	in	r17, 0x16	; 22
 556:	01 27       	eor	r16, r17
 558:	00 fb       	bst	r16, 0
 55a:	23 f9       	bld	r18, 3
 55c:	4f ef       	ldi	r20, 0xFF	; 255
 55e:	00 00       	nop
 560:	51 c0       	rjmp	.+162    	; 0x604 <rxbit4>

00000562 <shortcutToStart>:
 562:	05 e0       	ldi	r16, 0x05	; 5

00000564 <waitForJ1>:
 564:	b0 9b       	sbis	0x16, 0	; 22
 566:	fe cf       	rjmp	.-4      	; 0x564 <waitForJ1>

00000568 <waitForK1>:
 568:	0a 95       	dec	r16
 56a:	b0 99       	sbic	0x16, 0	; 22
 56c:	e9 f7       	brne	.-6      	; 0x568 <waitForK1>
 56e:	df 91       	pop	r29
 570:	00 c0       	rjmp	.+0      	; 0x572 <waitForK1+0xa>
 572:	d1 cf       	rjmp	.-94     	; 0x516 <shortcutEntry>

00000574 <stuffed5>:
 574:	16 b3       	in	r17, 0x16	; 22
 576:	13 70       	andi	r17, 0x03	; 3
 578:	79 f1       	breq	.+94     	; 0x5d8 <se0a>
 57a:	4f 7d       	andi	r20, 0xDF	; 223
 57c:	20 62       	ori	r18, 0x20	; 32
 57e:	13 c0       	rjmp	.+38     	; 0x5a6 <rxbit6>

00000580 <stuffed6>:
 580:	06 b3       	in	r16, 0x16	; 22
 582:	03 70       	andi	r16, 0x03	; 3
 584:	49 f1       	breq	.+82     	; 0x5d8 <se0a>
 586:	4f 7b       	andi	r20, 0xBF	; 191
 588:	20 64       	ori	r18, 0x40	; 64
 58a:	15 c0       	rjmp	.+42     	; 0x5b6 <rxbit7>

0000058c <stuffed7>:
 58c:	03 70       	andi	r16, 0x03	; 3
 58e:	21 f1       	breq	.+72     	; 0x5d8 <se0a>
 590:	10 2f       	mov	r17, r16
 592:	20 68       	ori	r18, 0x80	; 128
 594:	06 b3       	in	r16, 0x16	; 22
 596:	19 c0       	rjmp	.+50     	; 0x5ca <unstuffed7>

00000598 <stuffed0>:
 598:	06 b3       	in	r16, 0x16	; 22
 59a:	03 70       	andi	r16, 0x03	; 3
 59c:	e9 f0       	breq	.+58     	; 0x5d8 <se0a>
 59e:	4e 7f       	andi	r20, 0xFE	; 254
 5a0:	21 60       	ori	r18, 0x01	; 1
 5a2:	18 c0       	rjmp	.+48     	; 0x5d4 <rxbit1>

000005a4 <rxLoop>:
 5a4:	39 f3       	breq	.-50     	; 0x574 <stuffed5>

000005a6 <rxbit6>:
 5a6:	06 b3       	in	r16, 0x16	; 22
 5a8:	03 70       	andi	r16, 0x03	; 3
 5aa:	b1 f0       	breq	.+44     	; 0x5d8 <se0a>
 5ac:	10 27       	eor	r17, r16
 5ae:	10 fb       	bst	r17, 0
 5b0:	26 f9       	bld	r18, 6
 5b2:	22 30       	cpi	r18, 0x02	; 2
 5b4:	28 f3       	brcs	.-54     	; 0x580 <stuffed6>

000005b6 <rxbit7>:
 5b6:	16 b3       	in	r17, 0x16	; 22
 5b8:	01 27       	eor	r16, r17
 5ba:	00 fb       	bst	r16, 0
 5bc:	27 f9       	bld	r18, 7
 5be:	42 27       	eor	r20, r18
 5c0:	49 93       	st	Y+, r20
 5c2:	4f ef       	ldi	r20, 0xFF	; 255

000005c4 <rxbit0>:
 5c4:	06 b3       	in	r16, 0x16	; 22
 5c6:	24 30       	cpi	r18, 0x04	; 4
 5c8:	08 f3       	brcs	.-62     	; 0x58c <stuffed7>

000005ca <unstuffed7>:
 5ca:	10 27       	eor	r17, r16
 5cc:	10 fb       	bst	r17, 0
 5ce:	20 f9       	bld	r18, 0
 5d0:	29 7f       	andi	r18, 0xF9	; 249
 5d2:	11 f3       	breq	.-60     	; 0x598 <stuffed0>

000005d4 <rxbit1>:
 5d4:	16 b3       	in	r17, 0x16	; 22
 5d6:	13 70       	andi	r17, 0x03	; 3

000005d8 <se0a>:
 5d8:	e1 f1       	breq	.+120    	; 0x652 <se0>
 5da:	01 27       	eor	r16, r17
 5dc:	00 fb       	bst	r16, 0
 5de:	21 f9       	bld	r18, 1
 5e0:	23 7f       	andi	r18, 0xF3	; 243
 5e2:	f1 f0       	breq	.+60     	; 0x620 <stuffed1>

000005e4 <rxbit2>:
 5e4:	06 b3       	in	r16, 0x16	; 22
 5e6:	03 70       	andi	r16, 0x03	; 3
 5e8:	a1 f1       	breq	.+104    	; 0x652 <se0>
 5ea:	10 27       	eor	r17, r16
 5ec:	10 fb       	bst	r17, 0
 5ee:	22 f9       	bld	r18, 2
 5f0:	27 7e       	andi	r18, 0xE7	; 231
 5f2:	e1 f0       	breq	.+56     	; 0x62c <stuffed2>

000005f4 <rxbit3>:
 5f4:	16 b3       	in	r17, 0x16	; 22
 5f6:	01 27       	eor	r16, r17
 5f8:	00 fb       	bst	r16, 0
 5fa:	23 f9       	bld	r18, 3
 5fc:	3a 95       	dec	r19
 5fe:	41 f1       	breq	.+80     	; 0x650 <overflow>
 600:	2f 7c       	andi	r18, 0xCF	; 207
 602:	d1 f0       	breq	.+52     	; 0x638 <stuffed3>

00000604 <rxbit4>:
 604:	06 b3       	in	r16, 0x16	; 22
 606:	03 70       	andi	r16, 0x03	; 3
 608:	21 f1       	breq	.+72     	; 0x652 <se0>
 60a:	10 27       	eor	r17, r16
 60c:	10 fb       	bst	r17, 0
 60e:	24 f9       	bld	r18, 4
 610:	2f 79       	andi	r18, 0x9F	; 159
 612:	c1 f0       	breq	.+48     	; 0x644 <stuffed4>

00000614 <rxbit5>:
 614:	16 b3       	in	r17, 0x16	; 22
 616:	01 27       	eor	r16, r17
 618:	00 fb       	bst	r16, 0
 61a:	25 f9       	bld	r18, 5
 61c:	2f 73       	andi	r18, 0x3F	; 63
 61e:	c2 cf       	rjmp	.-124    	; 0x5a4 <rxLoop>

00000620 <stuffed1>:
 620:	16 b3       	in	r17, 0x16	; 22
 622:	13 70       	andi	r17, 0x03	; 3
 624:	b1 f0       	breq	.+44     	; 0x652 <se0>
 626:	4d 7f       	andi	r20, 0xFD	; 253
 628:	22 60       	ori	r18, 0x02	; 2
 62a:	dc cf       	rjmp	.-72     	; 0x5e4 <rxbit2>

0000062c <stuffed2>:
 62c:	06 b3       	in	r16, 0x16	; 22
 62e:	03 70       	andi	r16, 0x03	; 3
 630:	81 f0       	breq	.+32     	; 0x652 <se0>
 632:	4b 7f       	andi	r20, 0xFB	; 251
 634:	24 60       	ori	r18, 0x04	; 4
 636:	de cf       	rjmp	.-68     	; 0x5f4 <rxbit3>

00000638 <stuffed3>:
 638:	16 b3       	in	r17, 0x16	; 22
 63a:	13 70       	andi	r17, 0x03	; 3
 63c:	51 f0       	breq	.+20     	; 0x652 <se0>
 63e:	47 7f       	andi	r20, 0xF7	; 247
 640:	28 60       	ori	r18, 0x08	; 8
 642:	e0 cf       	rjmp	.-64     	; 0x604 <rxbit4>

00000644 <stuffed4>:
 644:	06 b3       	in	r16, 0x16	; 22
 646:	03 70       	andi	r16, 0x03	; 3
 648:	21 f0       	breq	.+8      	; 0x652 <se0>
 64a:	4f 7e       	andi	r20, 0xEF	; 239
 64c:	20 61       	ori	r18, 0x10	; 16
 64e:	e2 cf       	rjmp	.-60     	; 0x614 <rxbit5>

00000650 <overflow>:
 650:	3d c0       	rjmp	.+122    	; 0x6cc <rxDoReturn>

00000652 <se0>:
 652:	3c 2f       	mov	r19, r28
 654:	c0 91 9f 00 	lds	r28, 0x009F
 658:	3c 1b       	sub	r19, r28
 65a:	00 e4       	ldi	r16, 0x40	; 64
 65c:	33 30       	cpi	r19, 0x03	; 3
 65e:	0a bf       	out	0x3a, r16	; 58
 660:	a8 f1       	brcs	.+106    	; 0x6cc <rxDoReturn>
 662:	08 81       	ld	r16, Y
 664:	19 81       	ldd	r17, Y+1	; 0x01
 666:	41 2f       	mov	r20, r17
 668:	1f 77       	andi	r17, 0x7F	; 127
 66a:	20 91 a0 00 	lds	r18, 0x00A0
 66e:	0d 32       	cpi	r16, 0x2D	; 45
 670:	89 f1       	breq	.+98     	; 0x6d4 <isSetupOrOut>
 672:	01 3e       	cpi	r16, 0xE1	; 225
 674:	79 f1       	breq	.+94     	; 0x6d4 <isSetupOrOut>
 676:	09 36       	cpi	r16, 0x69	; 105
 678:	c1 f0       	breq	.+48     	; 0x6aa <handleIn>
 67a:	07 77       	andi	r16, 0x77	; 119
 67c:	03 34       	cpi	r16, 0x43	; 67
 67e:	31 f5       	brne	.+76     	; 0x6cc <rxDoReturn>

00000680 <isData>:
 680:	10 91 a7 00 	lds	r17, 0x00A7
 684:	11 23       	and	r17, r17
 686:	11 f1       	breq	.+68     	; 0x6cc <rxDoReturn>
 688:	00 91 a5 00 	lds	r16, 0x00A5
 68c:	00 30       	cpi	r16, 0x00	; 0
 68e:	d1 f5       	brne	.+116    	; 0x704 <sendNakAndReti>
 690:	34 30       	cpi	r19, 0x04	; 4
 692:	d2 f1       	brmi	.+116    	; 0x708 <sendAckAndReti>
 694:	30 93 a5 00 	sts	0x00A5, r19
 698:	10 93 a1 00 	sts	0x00A1, r17
 69c:	00 91 93 00 	lds	r16, 0x0093
 6a0:	c0 93 93 00 	sts	0x0093, r28
 6a4:	00 93 9f 00 	sts	0x009F, r16
 6a8:	2f c0       	rjmp	.+94     	; 0x708 <sendAckAndReti>

000006aa <handleIn>:
 6aa:	12 17       	cp	r17, r18
 6ac:	79 f4       	brne	.+30     	; 0x6cc <rxDoReturn>
 6ae:	47 fd       	sbrc	r20, 7
 6b0:	37 c0       	rjmp	.+110    	; 0x720 <handleIn1>
 6b2:	30 91 61 00 	lds	r19, 0x0061
 6b6:	34 fd       	sbrc	r19, 4
 6b8:	23 c0       	rjmp	.+70     	; 0x700 <sendCntAndReti>
 6ba:	0a e5       	ldi	r16, 0x5A	; 90
 6bc:	00 93 61 00 	sts	0x0061, r16
 6c0:	c8 e8       	ldi	r28, 0x88	; 136
 6c2:	d0 e0       	ldi	r29, 0x00	; 0
 6c4:	25 c0       	rjmp	.+74     	; 0x710 <usbSendAndReti>

000006c6 <otherOutOrSetup>:
 6c6:	00 27       	eor	r16, r16
 6c8:	00 93 a7 00 	sts	0x00A7, r16

000006cc <rxDoReturn>:
 6cc:	4f 91       	pop	r20
 6ce:	cf 91       	pop	r28
 6d0:	df 91       	pop	r29
 6d2:	0d c0       	rjmp	.+26     	; 0x6ee <sofError>

000006d4 <isSetupOrOut>:
 6d4:	12 17       	cp	r17, r18
 6d6:	b9 f7       	brne	.-18     	; 0x6c6 <otherOutOrSetup>
 6d8:	00 93 a7 00 	sts	0x00A7, r16
 6dc:	0a e5       	ldi	r16, 0x5A	; 90
 6de:	00 93 61 00 	sts	0x0061, r16

000006e2 <dontResetEP0>:
 6e2:	4f 91       	pop	r20
 6e4:	cf 91       	pop	r28
 6e6:	0a b7       	in	r16, 0x3a	; 58
 6e8:	06 fd       	sbrc	r16, 6
 6ea:	3b cf       	rjmp	.-394    	; 0x562 <shortcutToStart>
 6ec:	df 91       	pop	r29

000006ee <sofError>:
 6ee:	00 e4       	ldi	r16, 0x40	; 64
 6f0:	0a bf       	out	0x3a, r16	; 58
 6f2:	2f 91       	pop	r18
 6f4:	3f 91       	pop	r19
 6f6:	1f 91       	pop	r17
 6f8:	0f 91       	pop	r16
 6fa:	0f bf       	out	0x3f, r16	; 63
 6fc:	0f 91       	pop	r16
 6fe:	18 95       	reti

00000700 <sendCntAndReti>:
 700:	43 2f       	mov	r20, r19
 702:	03 c0       	rjmp	.+6      	; 0x70a <usbSendX3>

00000704 <sendNakAndReti>:
 704:	4a e5       	ldi	r20, 0x5A	; 90
 706:	01 c0       	rjmp	.+2      	; 0x70a <usbSendX3>

00000708 <sendAckAndReti>:
 708:	42 ed       	ldi	r20, 0xD2	; 210

0000070a <usbSendX3>:
 70a:	c4 e1       	ldi	r28, 0x14	; 20
 70c:	d0 e0       	ldi	r29, 0x00	; 0
 70e:	32 e0       	ldi	r19, 0x02	; 2

00000710 <usbSendAndReti>:
 710:	5f 93       	push	r21
 712:	53 e0       	ldi	r21, 0x03	; 3
 714:	c0 9a       	sbi	0x18, 0	; 24
 716:	08 b3       	in	r16, 0x18	; 24
 718:	b8 9a       	sbi	0x17, 0	; 23
 71a:	b9 9a       	sbi	0x17, 1	; 23
 71c:	20 e8       	ldi	r18, 0x80	; 128
 71e:	19 c0       	rjmp	.+50     	; 0x752 <txLoop>

00000720 <handleIn1>:
 720:	0a e5       	ldi	r16, 0x5A	; 90
 722:	30 91 62 00 	lds	r19, 0x0062
 726:	34 fd       	sbrc	r19, 4
 728:	eb cf       	rjmp	.-42     	; 0x700 <sendCntAndReti>
 72a:	00 93 62 00 	sts	0x0062, r16
 72e:	c4 e9       	ldi	r28, 0x94	; 148
 730:	d0 e0       	ldi	r29, 0x00	; 0
 732:	ee cf       	rjmp	.-36     	; 0x710 <usbSendAndReti>

00000734 <bitstuff0>:
 734:	05 27       	eor	r16, r21
 736:	10 e0       	ldi	r17, 0x00	; 0
 738:	08 bb       	out	0x18, r16	; 24
 73a:	10 c0       	rjmp	.+32     	; 0x75c <didStuff0>

0000073c <bitstuff1>:
 73c:	05 27       	eor	r16, r21
 73e:	10 e0       	ldi	r17, 0x00	; 0
 740:	08 94       	sec
 742:	08 bb       	out	0x18, r16	; 24
 744:	13 c0       	rjmp	.+38     	; 0x76c <didStuff1>

00000746 <bitstuff2>:
 746:	05 27       	eor	r16, r21
 748:	10 e0       	ldi	r17, 0x00	; 0
 74a:	15 c0       	rjmp	.+42     	; 0x776 <didStuff2>

0000074c <bitstuff3>:
 74c:	05 27       	eor	r16, r21
 74e:	10 e0       	ldi	r17, 0x00	; 0
 750:	19 c0       	rjmp	.+50     	; 0x784 <didStuff3>

00000752 <txLoop>:
 752:	20 ff       	sbrs	r18, 0
 754:	05 27       	eor	r16, r21
 756:	08 bb       	out	0x18, r16	; 24
 758:	27 95       	ror	r18
 75a:	17 95       	ror	r17

0000075c <didStuff0>:
 75c:	1c 3f       	cpi	r17, 0xFC	; 252
 75e:	50 f7       	brcc	.-44     	; 0x734 <bitstuff0>
 760:	20 ff       	sbrs	r18, 0
 762:	05 27       	eor	r16, r21
 764:	27 95       	ror	r18
 766:	08 bb       	out	0x18, r16	; 24
 768:	17 95       	ror	r17
 76a:	1c 3f       	cpi	r17, 0xFC	; 252

0000076c <didStuff1>:
 76c:	38 f7       	brcc	.-50     	; 0x73c <bitstuff1>
 76e:	20 ff       	sbrs	r18, 0
 770:	05 27       	eor	r16, r21
 772:	27 95       	ror	r18
 774:	17 95       	ror	r17

00000776 <didStuff2>:
 776:	08 bb       	out	0x18, r16	; 24
 778:	1c 3f       	cpi	r17, 0xFC	; 252
 77a:	28 f7       	brcc	.-54     	; 0x746 <bitstuff2>
 77c:	20 ff       	sbrs	r18, 0
 77e:	05 27       	eor	r16, r21
 780:	27 95       	ror	r18
 782:	17 95       	ror	r17

00000784 <didStuff3>:
 784:	1c 3f       	cpi	r17, 0xFC	; 252
 786:	08 bb       	out	0x18, r16	; 24
 788:	08 f7       	brcc	.-62     	; 0x74c <bitstuff3>
 78a:	00 c0       	rjmp	.+0      	; 0x78c <didStuff3+0x8>
 78c:	49 91       	ld	r20, Y+
 78e:	20 ff       	sbrs	r18, 0
 790:	05 27       	eor	r16, r21
 792:	08 bb       	out	0x18, r16	; 24
 794:	27 95       	ror	r18
 796:	17 95       	ror	r17

00000798 <didStuff4>:
 798:	1c 3f       	cpi	r17, 0xFC	; 252
 79a:	80 f5       	brcc	.+96     	; 0x7fc <bitstuff4>
 79c:	20 ff       	sbrs	r18, 0
 79e:	05 27       	eor	r16, r21
 7a0:	27 95       	ror	r18
 7a2:	08 bb       	out	0x18, r16	; 24
 7a4:	17 95       	ror	r17
 7a6:	1c 3f       	cpi	r17, 0xFC	; 252

000007a8 <didStuff5>:
 7a8:	68 f5       	brcc	.+90     	; 0x804 <bitstuff5>
 7aa:	20 ff       	sbrs	r18, 0
 7ac:	05 27       	eor	r16, r21
 7ae:	27 95       	ror	r18
 7b0:	17 95       	ror	r17

000007b2 <didStuff6>:
 7b2:	08 bb       	out	0x18, r16	; 24
 7b4:	1c 3f       	cpi	r17, 0xFC	; 252
 7b6:	58 f5       	brcc	.+86     	; 0x80e <bitstuff6>
 7b8:	20 ff       	sbrs	r18, 0
 7ba:	05 27       	eor	r16, r21
 7bc:	27 95       	ror	r18
 7be:	17 95       	ror	r17

000007c0 <didStuff7>:
 7c0:	1c 3f       	cpi	r17, 0xFC	; 252
 7c2:	08 bb       	out	0x18, r16	; 24
 7c4:	38 f5       	brcc	.+78     	; 0x814 <bitstuff7>
 7c6:	24 2f       	mov	r18, r20
 7c8:	3a 95       	dec	r19
 7ca:	19 f6       	brne	.-122    	; 0x752 <txLoop>
 7cc:	0c 7f       	andi	r16, 0xFC	; 252
 7ce:	5f 91       	pop	r21
 7d0:	08 bb       	out	0x18, r16	; 24
 7d2:	32 e0       	ldi	r19, 0x02	; 2

000007d4 <se0Delay>:
 7d4:	3a 95       	dec	r19
 7d6:	f1 f7       	brne	.-4      	; 0x7d4 <se0Delay>
 7d8:	10 91 a6 00 	lds	r17, 0x00A6
 7dc:	c6 51       	subi	r28, 0x16	; 22
 7de:	d0 40       	sbci	r29, 0x00	; 0
 7e0:	11 f0       	breq	.+4      	; 0x7e6 <skipAddrAssign>
 7e2:	10 93 a0 00 	sts	0x00A0, r17

000007e6 <skipAddrAssign>:
 7e6:	01 60       	ori	r16, 0x01	; 1
 7e8:	17 b3       	in	r17, 0x17	; 23
 7ea:	1c 7f       	andi	r17, 0xFC	; 252
 7ec:	08 bb       	out	0x18, r16	; 24
 7ee:	0c 7f       	andi	r16, 0xFC	; 252
 7f0:	4f 91       	pop	r20
 7f2:	cf 91       	pop	r28
 7f4:	17 bb       	out	0x17, r17	; 23
 7f6:	08 bb       	out	0x18, r16	; 24
 7f8:	df 91       	pop	r29
 7fa:	79 cf       	rjmp	.-270    	; 0x6ee <sofError>

000007fc <bitstuff4>:
 7fc:	05 27       	eor	r16, r21
 7fe:	10 e0       	ldi	r17, 0x00	; 0
 800:	08 bb       	out	0x18, r16	; 24
 802:	ca cf       	rjmp	.-108    	; 0x798 <didStuff4>

00000804 <bitstuff5>:
 804:	05 27       	eor	r16, r21
 806:	10 e0       	ldi	r17, 0x00	; 0
 808:	08 94       	sec
 80a:	08 bb       	out	0x18, r16	; 24
 80c:	cd cf       	rjmp	.-102    	; 0x7a8 <didStuff5>

0000080e <bitstuff6>:
 80e:	05 27       	eor	r16, r21
 810:	10 e0       	ldi	r17, 0x00	; 0
 812:	cf cf       	rjmp	.-98     	; 0x7b2 <didStuff6>

00000814 <bitstuff7>:
 814:	05 27       	eor	r16, r21
 816:	10 e0       	ldi	r17, 0x00	; 0
 818:	d3 cf       	rjmp	.-90     	; 0x7c0 <didStuff7>

0000081a <usbCrc16>:
 81a:	a8 2f       	mov	r26, r24
 81c:	b9 2f       	mov	r27, r25
 81e:	8f ef       	ldi	r24, 0xFF	; 255
 820:	9f ef       	ldi	r25, 0xFF	; 255
 822:	41 e0       	ldi	r20, 0x01	; 1
 824:	50 ea       	ldi	r21, 0xA0	; 160

00000826 <crcByteLoop>:
 826:	61 50       	subi	r22, 0x01	; 1
 828:	70 f0       	brcs	.+28     	; 0x846 <crcReady>
 82a:	2d 91       	ld	r18, X+
 82c:	38 e0       	ldi	r19, 0x08	; 8

0000082e <crcBitLoop>:
 82e:	72 2f       	mov	r23, r18
 830:	78 27       	eor	r23, r24
 832:	96 95       	lsr	r25
 834:	87 95       	ror	r24
 836:	26 95       	lsr	r18
 838:	70 ff       	sbrs	r23, 0
 83a:	02 c0       	rjmp	.+4      	; 0x840 <crcNoXor>
 83c:	84 27       	eor	r24, r20
 83e:	95 27       	eor	r25, r21

00000840 <crcNoXor>:
 840:	3a 95       	dec	r19
 842:	a9 f7       	brne	.-22     	; 0x82e <crcBitLoop>
 844:	f0 cf       	rjmp	.-32     	; 0x826 <crcByteLoop>

00000846 <crcReady>:
 846:	80 95       	com	r24
 848:	90 95       	com	r25
 84a:	08 95       	ret

0000084c <usbCrc16Append>:
 84c:	e6 df       	rcall	.-52     	; 0x81a <usbCrc16>
 84e:	8d 93       	st	X+, r24
 850:	9d 93       	st	X+, r25
 852:	08 95       	ret

00000854 <_exit>:
 854:	f8 94       	cli

00000856 <__stop_program>:
 856:	ff cf       	rjmp	.-2      	; 0x856 <__stop_program>
